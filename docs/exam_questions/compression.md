# שאלות מבחן - דחיסה

---

## שאלה 1: בניית עץ האפמן (2023b מועד א', שאלה 3א')

**נתון:**
```python
corpus = 4*'a' + 5*'b' + 6*'c' + 7*'d' + 10*'e' + 15*'f'
```

**שאלה:** בנו את עץ האפמן וקודדו את "fadee".

**פתרון:**
1. בנה עץ מהתדירויות הנמוכות לגבוהות
2. תדירויות: a=4, b=5, c=6, d=7, e=10, f=15

**טריק חשוב:** תמיד ממזגים את שני הצמתים עם התדירות הנמוכה ביותר!

---

## שאלה 2: שחזור עץ האפמן מהודעות (2023b מועד א', שאלה 3ב')

**נתון:**
- 6 אותיות: e, t, a, o, i, n (לפי שכיחות יורדת)
- e מקודדת ב-"0"
- הודעות: 011, 11101, 01011001

**שאלה:** שחזר את עץ האפמן ופענח הודעה ג'.

**טריק חשוב:**
- אם e מקודדת ב-"0", היא בן ישיר של השורש
- ניתן לשחזר את העץ מהודעות תקינות

---

## שאלה 3: Lempel-Ziv - אורך חזרה מינימלי (2023a מועד א', שאלה 1ב')

**נתון:** W=200, L=50 (במקום ברירות המחדל)

**שאלה:** מהו אורך החזרה המינימלי שכדאי לדחוס?

**פתרון:**
- ייצוג ללא דחיסה: 8 ביטים לתו (ASCII)
- ייצוג עם דחיסה: log₂(W) + log₂(L) + 8 = 8 + 6 + 8 = 22 ביטים
- אורך מינימלי: ⌈22/8⌉ = 3 תווים

**טריק חשוב:** השווה עלות דחיסה vs עלות ללא דחיסה!

---

## שאלה 4: האפמן vs LZ (2023b מועד א', שאלה 3ג')

**טענות לבדיקה:**

1. `len(H_compress(s,s)) == len(H_compress(s,s[::-1]))`
   **נכון** - אותן תדירויות, אותם אורכי קודים

2. `len(H_compress(LZ_compress(s), LZ_compress(s))) == len(LZ_compress(s))`
   **נכון** - האפמן על מחרוזת עם עצמה כקורפוס = זהות

3. `len(LZ_compress(H_compress(s, s))) == len(H_compress(s, s))`
   **לא נכון** - LZ יכול לדחוס יותר את הפלט של האפמן (חזרות)

---

## שאלה 5: עץ האפמן מאוזן (2022b מועד א', שאלה 1ו')

**שאלה:** מתי עץ האפמן יהיה מאוזן?

**תשובות:**
- `10*'a' + 10*'b' + 10*'c' + 10*'d'` → **מאוזן** (תדירויות שוות)
- `10*'a' + 5*'b' + 15*'c' + 16*'d'` → **לא מאוזן**
- תדירויות שהן חזקות של 2 → תלוי מימוש

---

## שאלה 6: קוד האפמן עם 128 תווים (2024a מועד א', שאלה 1ה')

**נתון:** קורפוס עם 128 תווים שונים, שכיחויות a₁ < a₂ < ... < aₙ כאשר aₙ < 2·a₁

**שאלה:** מה ההפרש בין אורך הקידוד של התו בעל השכיחות הנמוכה ביותר (l) לבין אורך הקידוד של התו בעל השכיחות הגבוהה ביותר (u)?

**תשובה:** l - u = 1

**הסבר:** כאשר aₙ < 2·a₁, ההבדל בין השכיחויות לא גדול מספיק כדי שיהיה הבדל של יותר מ-1 בין אורכי הקידודים.

---

## שאלה 7: Lempel-Ziv עם פרמטרים (2024a מועד א', שאלה 1ו')

**נתון:** דוחסים "abcdab" עם W = 2¹⁰-1, L = 2³-1

**שאלה:** כמה ביטים במחרוזת הדחוסה?

**פתרון:**
- אורך ייצוג חזרה: log₂(W) + log₂(L) + 1 = 10 + 3 + 1 = 14 ביטים
- תו לא דחוס: 8 ביטים
- "ab" בהתחלה: 2×8 = 16 ביטים
- "cd": 2×8 = 16 ביטים
- "ab" חוזר? אורך 2, צריך 14 ביטים לחזרה vs 16 לתווים - כדאי לדחוס!

**תשובה:** 16 + 16 + 14 = 46 ביטים (או פתרון אחר לפי פרשנות)

---

## שאלה 8: Prefix-Free Codes (2025a מועד א', שאלה 1ב')

**נתון:** א"ב {a, b, c, d} וחמישה קידודים

| קידוד | סוג |
|-------|------|
| a=0, b=00, c=000, d=0000 | not uniquely decodable |
| a=00, b=01, c=10, d=11 | prefix free |
| a=00, b=01, c=101, d=110 | prefix free |
| a=10, b=101, c=1011, d=11 | uniquely decodable but not prefix free |
| a=0, b=01, c=011, d=0111 | not uniquely decodable |

**טריק חשוב:** קוד הוא prefix-free אם אף מילת קוד אינה רישא של אחרת!

---

## שאלה 9: Lempel-Ziv עם חזרות לאחור (2025a מועד א', שאלה 3)

**רעיון חדש:** מאפשרים חזרות "לאחור" - אם היה "abc" ובהמשך "cba", ניתן לקודד את "cba" כחזרה לאחור.

**ייצוג חזרה:** [m, k, b] כאשר:
- m = היסט לאחור
- k = אורך חזרה
- b = 0 אם חזרה רגילה, 1 אם חזרה לאחור

**דוגמאות:**
- "abcdeabcde" → ["a", "b", "c", "d", "e", [5,5,0]]
- "abcdeedcba" → ["a", "b", "c", "d", "e", [1,5,1]]

**אורך חזרה מינימלי:** 3 (כי חזרה = 19 ביטים, 3 תווים = 24 ביטים)

---

## שאלה 10: דחיסת מחרוזות באורך 2 (2024a מועד ב', שאלה 4)

**רעיון:** במקום קידוד תו בודד, מקודדים זוגות תווים (מחרוזות באורך 2)

```python
def compress_pairs(text, pairhcode):
    return "".join([pairhcode[text[i:i+2]] for i in range(0,len(text),2)])
```

**שאלות:**
1. האם `len(compress(s,hcode)) == len(compress(s[::-1],hcode))`? **כן** - אותן תדירויות
2. האם `len(compress_pairs(s,pairhcode)) == len(compress_pairs(s[::-1],pairhcode))`? **לא** - זוגות שונים!

**דוגמה:** "ab" הפוך הוא "ba", אבל "ab" ו-"ba" הם זוגות שונים עם קידודים שונים.

---

## שאלה 11: עץ האפמן טרינארי (2024b מועד א', שאלה 4)

**רקע:** עץ האפמן טרינארי משתמש ב-3 ערכים (0, 1, *) במקום 2.
- בכל שלב מאחדים 3 צמתים עם השכיחויות המינימליות
- אם מספר התווים זוגי, לשורש יהיו רק 2 בנים

**שאלה א:** נתון קורפוס עם k תווים (k אי-זוגי, k≥3) עם תדירויות 2^(i-1) לתו xi.
מהו עומק העץ?

**תשובה:** עומק = (k-1)/2

**שאלה ב:** 82 תווים שונים, A עם שכיחות k, שאר התווים שכיחות 1.
מהו k המינימלי כדי ש-A יקבל קידוד באורך 1?

**תשובה:** k = 81 (צריך שהשכיחות של A תהיה לפחות כסכום כל השאר)

---

## שאלה 12: אורך קידוד האפמן (2024b מועד ב', שאלה 1ג')

**שאלה:** מהו אורך קידוד האפמן עבור כל מחרוזת (כשהקורפוס הוא המחרוזת עצמה)?

| מחרוזת | אורך |
|--------|------|
| 'abcd' | 8 ביטים (4 תווים × 2 ביטים) |
| 'aabbccdd' | 16 ביטים (8 תווים × 2 ביטים) |
| '4444221' | 10 ביטים (4×1 + 2×2 + 1×2) |
| '4444333221' | 17 ביטים |
| 'hello' | 9 ביטים |

**טריק חשוב:** כשכל התווים בשכיחות שווה, כל תו מקודד באותו אורך!

---

## שאלה 13: char_count - השוואת סיבוכיות (2025a מועד ב', שאלה 3)

**גרסה 1 - עם מילון:**
```python
def char_count(corpus):
    d = {}
    for ch in corpus:
        if ch in d:
            d[ch] += 1
        else:
            d[ch] = 1
    return d
```

**גרסה 2 - עם רשימה ו-index:**
```python
def char_count2(corpus):
    alphabet = ["a", "b", "c", "d", "e", "f"]
    char_counts = [0 for ch in alphabet]
    for ch in corpus:
        char_counts[alphabet.index(ch)] += 1
    return {alphabet[i]:char_counts[i] for i in range(len(alphabet))}
```

**השוואת סיבוכיות:**

| פונקציה | ממוצע | מקרה גרוע |
|---------|-------|-----------|
| char_count | O(n) | O(n²) - hash collisions |
| char_count2 | O(n) | O(n) - index הוא O(1) עבור אלפבית קבוע |

**דוגמה:** `char_count2("aaabbc")` → `{'a': 3, 'b': 2, 'c': 1, 'd': 0, 'e': 0, 'f': 0}`

---

## שאלה 14: char_count_pairs - ספירת זוגות (2025a מועד ב', שאלה 3ג')

```python
def char_count_pairs(corpus):
    alphabet = ["a", "b", "c", "d", "e", "f"]
    pairs = [ch1+ch2 for ch1 in alphabet for ch2 in alphabet]
    counts = [0]*len(pairs)

    for i in range(len(corpus)-1):
        pair = corpus[i:i+2]
        counts[pairs.index(pair)] += 1

    return {pairs[i]:counts[i] for i in range(len(pairs))}
```

**דוגמה:** `char_count_pairs("aaabbc")` → `{'aa': 2, 'ab': 1, 'bb': 1, 'bc': 1, ...}`

---

## שאלה 15: האפמן + LZ משולב (2025b מועד א', שאלה 4)

**שינויים מהכיתה:**
1. תו בודד: "0" + huff(x) במקום "0" + ascii(x)
2. חזרה: 5 ביטים למרחק + 3 ביטים לאורך + "1" = 9 ביטים

**עץ האפמן:**
```
         ( )
        /   \
      ( )    f
     /   \
   ( )    ( )
  /   \  /   \
( )   c  d    e
/ \
a   b
```

**קידודים:** a="0000", b="0001", c="001", d="010", e="011", f="1"

**מתי לקודד חזרה?**
- חזרה = 9 ביטים
- תווים = סכום אורכי הקידודים + 1 לכל תו
- מקודדים חזרה רק אם קידוד תווים > 9

**דוגמה:**
- "ef" → 2+4 = 6 ביטים < 9 → **לא** לקודד כחזרה
- "abc" → 5+5+4 = 14 ביטים > 9 → **כן** לקודד כחזרה

**אורך מינימלי לחזרה:** 3 תווים (כי fff = 2+2+2 = 6 < 9, אבל aaa = 5+5+5 = 15 > 9)

---

## שאלה 16: פענוח האפמן+LZ (2025b מועד א', שאלה 4ב')

**פענוח "01001100010010100100011":**
1. "0" → תו: "1001" = d
2. "0" → תו: "1000" = ? (צריך לפענח לפי העץ)

**אלגוריתם פענוח:**
- אם מתחיל ב-"0": קרא קוד האפמן ופענח תו
- אם מתחיל ב-"1": קרא 5 ביטים (מרחק) + 3 ביטים (אורך), החזר חזרה

---

## שאלה 17: ייצוג ביניים של LZ (2025b מועד ב', שאלה 1ד')

**פרמטרים:** 12 ביטים להיסט, 5 ביטים לאורך חזרה, 7 ביטים לתו (ASCII).

**S1 = "ABACCBACACA"**

| אפשרות | ייצוג |
|--------|-------|
| i. | `['A', 'B', 'A', 'C', [3,5], [2,2]]` |
| ii. | `['A', 'B', 'A', 'C', [1,2], 'B','A','C',[3,3]]` |
| iii. | `['A', 'B', 'A', 'C', 'C',[4,3], 'A','C','A']` |
| iv. | `['A', 'B', 'A', 'C', 'C',[4,3], [2,3]]` ← **נכון** |
| v. | `['A', 'B', 'A', 'C', 'C', [3,4], [3,2]]` |

**הסבר לתשובה iv:**
- 'A','B','A','C','C' - 5 תווים
- [4,3] - חזרה על "BAC" (4 תווים אחורה, אורך 3)
- [2,3] - חזרה על "ACA" (2 תווים אחורה, אורך 3)

**S2 = "AAAABBBAAB"**

**תשובה:** `['A', [1,3], 'B', [1,3], [6,3]]`

**הסבר:**
- 'A' - תו ראשון
- [1,3] - חזרה על "AAA" (1 אחורה, אורך 3)
- 'B' - תו חדש
- [1,3] - חזרה על "BBB" (1 אחורה, אורך 3)
- [6,3] - חזרה על "AAB" (6 אחורה, אורך 3)

**טריק חשוב:** LZ יכול לדחוס רק אם אורך החזרה מספיק גדול (עלות חזרה < עלות תווים)!

---

## קישורים לסיכומים

- [דחיסה](../notes/compression.md)
- [טריקים לבחינה](../notes/exam_tricks.md)
