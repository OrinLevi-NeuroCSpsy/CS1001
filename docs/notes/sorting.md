# אלגוריתמי מיון (Sorting) - סיכום לבחינה

---

## מבוא

**מיון** = סידור איברים בסדר מסוים (עולה/יורד).

### סיווג אלגוריתמי מיון

| קריטריון | אפשרויות |
|----------|----------|
| סיבוכיות | O(n²) פשוטים / O(n log n) יעילים |
| מקום | In-place (O(1)) / צורך זיכרון נוסף |
| יציבות | Stable / Not stable |

**יציבות (Stability):** אלגוריתם יציב שומר על הסדר היחסי של איברים שווים.

---

## Selection Sort (מיון בחירה)

### רעיון
בכל סיבוב, מוצאים את **המינימום** מהחלק הלא ממוין ושמים אותו במקומו.

### אינטואיציה
כמו לסדר קלפים: כל פעם מחפשים את הקטן ביותר ושמים בהתחלה.

### מימוש
```python
def selection_sort(lst):
    n = len(lst)
    for i in range(n - 1):
        # מצא אינדקס המינימום מ-i עד הסוף
        min_idx = i
        for j in range(i + 1, n):
            if lst[j] < lst[min_idx]:
                min_idx = j
        # החלף
        lst[i], lst[min_idx] = lst[min_idx], lst[i]
```

### מעקב (Trace)
```
[64, 25, 12, 22, 11]
 ↓ מינימום=11, החלף עם 64
[11, 25, 12, 22, 64]
     ↓ מינימום=12, החלף עם 25
[11, 12, 25, 22, 64]
         ↓ מינימום=22, החלף עם 25
[11, 12, 22, 25, 64]
             ↓ מינימום=25, כבר במקום
[11, 12, 22, 25, 64] ✓
```

### סיבוכיות
| מקרה | זמן | מקום |
|------|-----|------|
| תמיד | **O(n²)** | O(1) |

**למה O(n²)?** לולאה חיצונית n פעמים × לולאה פנימית עד n = n²

### יתרונות/חסרונות
- ✅ פשוט למימוש
- ✅ In-place (לא צריך זיכרון נוסף)
- ✅ מספר החלפות מינימלי: O(n)
- ❌ איטי: תמיד O(n²), גם על רשימה ממוינת
- ❌ לא יציב

---

## Insertion Sort (מיון הכנסה)

### רעיון
בונים רשימה ממוינת בהדרגה: בכל סיבוב לוקחים איבר ו**מכניסים** אותו למקום הנכון בחלק הממוין.

### אינטואיציה
כמו לסדר קלפים ביד: כל קלף חדש מכניסים למקום הנכון בין הקלפים שכבר ממוינים.

### מימוש
```python
def insertion_sort(lst):
    for i in range(1, len(lst)):
        key = lst[i]
        j = i - 1
        # הזז איברים גדולים מ-key ימינה
        while j >= 0 and lst[j] > key:
            lst[j + 1] = lst[j]
            j -= 1
        lst[j + 1] = key
```

### מעקב (Trace)
```
[5, 2, 4, 6, 1]
    ↓ key=2, הזז 5 ימינה, הכנס 2
[2, 5, 4, 6, 1]
       ↓ key=4, הזז 5 ימינה, הכנס 4
[2, 4, 5, 6, 1]
          ↓ key=6, כבר במקום
[2, 4, 5, 6, 1]
             ↓ key=1, הזז הכל ימינה, הכנס 1
[1, 2, 4, 5, 6] ✓
```

### סיבוכיות
| מקרה | זמן | סיבה |
|------|-----|------|
| גרוע (סדר הפוך) | O(n²) | כל איבר זז עד ההתחלה |
| ממוצע | O(n²) | |
| **טוב (כמעט ממוין)** | **O(n)** | כמעט אין הזזות |

**מקום:** O(1)

### יתרונות/חסרונות
- ✅ יעיל על רשימות קטנות או כמעט ממוינות
- ✅ In-place
- ✅ **יציב** (Stable)
- ✅ Online - יכול למיין תוך כדי קבלת קלט
- ❌ איטי על רשימות גדולות לא ממוינות

---

## Bubble Sort (מיון בועות)

### רעיון
עוברים שוב ושוב על הרשימה, ובכל מעבר **מחליפים** זוגות סמוכים בסדר שגוי. האיברים הגדולים "צפים" למעלה כמו בועות.

### מימוש
```python
def bubble_sort(lst):
    n = len(lst)
    for i in range(n - 1):
        swapped = False
        for j in range(n - 1 - i):
            if lst[j] > lst[j + 1]:
                lst[j], lst[j + 1] = lst[j + 1], lst[j]
                swapped = True
        if not swapped:  # אופטימיזציה: אם לא היו החלפות - ממוין
            break
```

### סיבוכיות
| מקרה | זמן |
|------|-----|
| גרוע | O(n²) |
| טוב (ממוין) | O(n) - עם האופטימיזציה |

**מקום:** O(1)

### יתרונות/חסרונות
- ✅ פשוט מאוד
- ✅ יציב
- ✅ In-place
- ❌ **האיטי ביותר** מבין אלגוריתמי O(n²)
- ❌ הרבה החלפות מיותרות

> **הערה:** Bubble Sort משמש בעיקר ללימוד. בפרקטיקה לא משתמשים בו.

---

## Merge Sort (מיון מיזוג)

### רעיון - הפרד ומשול (Divide & Conquer)
1. **פצל** את הרשימה לשני חצאים
2. **מיין רקורסיבית** כל חצי
3. **מזג** את שני החצאים הממוינים

### אינטואיציה
קל למזג שתי ערימות קלפים ממוינות: כל פעם לוקחים את הקטן מבין שני העליונים.

### מימוש
```python
def merge_sort(lst):
    if len(lst) <= 1:
        return lst

    mid = len(lst) // 2
    left = merge_sort(lst[:mid])
    right = merge_sort(lst[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    result.extend(left[i:])
    result.extend(right[j:])
    return result
```

### מעקב (Trace)
```
[38, 27, 43, 3]
       ↓ פצל
[38, 27]    [43, 3]
   ↓ פצל      ↓ פצל
[38] [27]  [43] [3]
   ↓ מזג      ↓ מזג
[27, 38]   [3, 43]
       ↓ מזג
[3, 27, 38, 43] ✓
```

### סיבוכיות
| מקרה | זמן | מקום |
|------|-----|------|
| **תמיד** | **O(n log n)** | O(n) |

**למה O(n log n)?**
- עומק הרקורסיה: log n (כל פעם מחלקים ב-2)
- בכל רמה: O(n) עבודה (מיזוג)
- סה"כ: O(n) × O(log n) = O(n log n)

### יתרונות/חסרונות
- ✅ **מהיר ועקבי**: תמיד O(n log n)
- ✅ יציב
- ✅ טוב לנתונים גדולים מאוד (external sort)
- ❌ צריך O(n) זיכרון נוסף
- ❌ לא In-place

---

## Quicksort (מיון מהיר)

### רעיון - הפרד ומשול
1. בחר **ציר (pivot)**
2. **חלק** את הרשימה: קטנים משמאל, גדולים מימין
3. **מיין רקורסיבית** כל צד

### אינטואיציה
כמו לחלק קלפים לשתי ערימות לפי ערך מסוים, ואז למיין כל ערימה בנפרד.

### מימוש (גרסה פשוטה)
```python
def quicksort(lst):
    if len(lst) <= 1:
        return lst

    pivot = lst[0]  # בחירת ציר (יש אסטרטגיות טובות יותר)

    less = [x for x in lst[1:] if x <= pivot]
    greater = [x for x in lst[1:] if x > pivot]

    return quicksort(less) + [pivot] + quicksort(greater)
```

### מימוש In-place (מתקדם)
```python
def quicksort_inplace(lst, low, high):
    if low < high:
        pivot_idx = partition(lst, low, high)
        quicksort_inplace(lst, low, pivot_idx - 1)
        quicksort_inplace(lst, pivot_idx + 1, high)

def partition(lst, low, high):
    pivot = lst[high]
    i = low - 1
    for j in range(low, high):
        if lst[j] <= pivot:
            i += 1
            lst[i], lst[j] = lst[j], lst[i]
    lst[i + 1], lst[high] = lst[high], lst[i + 1]
    return i + 1
```

### סיבוכיות
| מקרה | זמן | מתי? |
|------|-----|------|
| **ממוצע** | **O(n log n)** | בחירת pivot טובה |
| גרוע | O(n²) | pivot תמיד מינימום/מקסימום |

**מקום:** O(log n) לגרסה in-place (stack רקורסיה)

### יתרונות/חסרונות
- ✅ **המהיר ביותר בפרקטיקה** (ממוצע)
- ✅ In-place (בגרסה המתאימה)
- ✅ Cache-friendly
- ❌ מקרה גרוע O(n²)
- ❌ לא יציב
- ❌ רגיש לבחירת pivot

---

## טבלת השוואה מסכמת

| אלגוריתם | זמן (גרוע) | זמן (ממוצע) | זמן (טוב) | מקום | יציב? |
|----------|-----------|-------------|-----------|------|-------|
| Selection | O(n²) | O(n²) | O(n²) | O(1) | ❌ |
| Insertion | O(n²) | O(n²) | **O(n)** | O(1) | ✅ |
| Bubble | O(n²) | O(n²) | O(n) | O(1) | ✅ |
| **Merge** | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ |
| **Quick** | O(n²) | **O(n log n)** | O(n log n) | O(log n) | ❌ |

---

## מתי להשתמש במה?

| מצב | אלגוריתם מומלץ | סיבה |
|-----|----------------|------|
| רשימה קטנה (n < 50) | Insertion | פשוט ומהיר למקרים קטנים |
| רשימה כמעט ממוינת | Insertion | O(n) במקרה הטוב |
| צריך יציבות | Merge | יציב + O(n log n) |
| ביצועים כלליים | Quick | הכי מהיר בממוצע |
| זיכרון מוגבל | Quick (in-place) | O(log n) מקום |
| נתונים גדולים מאוד | Merge | עקבי, טוב ל-external sort |

---

## טעויות נפוצות בבחינות

### 1. בלבול בין Selection ל-Insertion
- **Selection:** מחפש מינימום ושם בהתחלה
- **Insertion:** לוקח איבר ומכניס למקום הנכון

### 2. שכחה שב-Merge צריך זיכרון נוסף
```python
# Merge Sort דורש O(n) זיכרון לרשימות הזמניות
```

### 3. חשיבה ש-Quicksort תמיד O(n log n)
```python
# מקרה גרוע: pivot תמיד קיצוני → O(n²)
# דוגמה: רשימה כבר ממוינת עם pivot=lst[0]
```

### 4. בלבול ביציבות
```python
# [(1,'a'), (1,'b'), (2,'c')]
# מיון יציב: (1,'a') יישאר לפני (1,'b')
# Selection Sort לא יציב - עלול להחליף!
```

### 5. שכחת תנאי עצירה ב-Merge Sort
```python
if len(lst) <= 1:  # חייב! אחרת רקורסיה אינסופית
    return lst
```

---

## שאלות בחינה טיפוסיות

### שאלה 1: מעקב על Selection Sort
```
מיין את [3, 1, 4, 1, 5] באמצעות Selection Sort. הראה כל שלב.
```

**פתרון:**
```
[3, 1, 4, 1, 5] → min=1(idx=1) → [1, 3, 4, 1, 5]
[1, 3, 4, 1, 5] → min=1(idx=3) → [1, 1, 4, 3, 5]
[1, 1, 4, 3, 5] → min=3(idx=3) → [1, 1, 3, 4, 5]
[1, 1, 3, 4, 5] → min=4(idx=3) → [1, 1, 3, 4, 5]
```

---

### שאלה 2: מהי סיבוכיות הזמן?
```python
def mystery_sort(lst):
    for i in range(len(lst)):
        for j in range(len(lst) - 1):
            if lst[j] > lst[j+1]:
                lst[j], lst[j+1] = lst[j+1], lst[j]
```

**תשובה:** O(n²) - זהו Bubble Sort ללא אופטימיזציה.

---

### שאלה 3: איזה אלגוריתם?
רשימה כמעט ממוינת עם 1000 איברים, רק 5 לא במקומם. מה עדיף?

**תשובה:** **Insertion Sort** - יעיל על רשימות כמעט ממוינות, O(n) במקרה זה.

---

## סיכום נקודות חשובות

- [ ] O(n²): Selection, Insertion, Bubble
- [ ] O(n log n): Merge, Quick (ממוצע)
- [ ] Insertion טוב לרשימות קטנות/כמעט ממוינות
- [ ] Merge יציב + תמיד O(n log n) אבל O(n) מקום
- [ ] Quick הכי מהיר בממוצע אבל O(n²) במקרה גרוע
- [ ] יציבות = שמירה על סדר יחסי של איברים שווים

---

## קישורים נוספים

- **קוד:** [sorting_demo.py](../code/sorting_demo.py)
