# חיפוש לינארי וחיפוש בינארי - סיכום לבחינה

---

## חיפוש לינארי (Linear Search)

### הגדרה פורמלית
אלגוריתם שעובר על כל איברי המערך בזה אחר זה, עד שמוצא את הערך המבוקש או מגיע לסוף.

### מימוש
```python
def linear_search(lst, target):
    for i in range(len(lst)):
        if lst[i] == target:
            return i
    return -1  # לא נמצא
```

### מאפיינים
| מאפיין | ערך |
|--------|-----|
| דרישות מוקדמות | **אין** - עובד על כל רשימה |
| סיבוכיות זמן (גרוע) | O(n) |
| סיבוכיות זמן (ממוצע) | O(n) |
| סיבוכיות זמן (טוב) | O(1) - אם האיבר ראשון |

---

## חיפוש בינארי (Binary Search)

### הגדרה פורמלית
אלגוריתם "הפרד ומשול" שמחפש ברשימה **ממוינת** על ידי חלוקת טווח החיפוש לשניים בכל איטרציה.

### הסבר אינטואיטיבי
כמו לחפש מילה במילון - פותחים באמצע, בודקים אם המילה לפני או אחרי, וממשיכים לחצי הרלוונטי.

### דרישה הכרחית
> **הרשימה חייבת להיות ממוינת!**
>
> חיפוש בינארי על רשימה לא ממוינת יתן תוצאות שגויות.

### מימוש איטרטיבי
```python
def binary_search(lst, target):
    low = 0
    high = len(lst) - 1

    while low <= high:
        mid = (low + high) // 2

        if lst[mid] == target:
            return mid
        elif lst[mid] < target:
            low = mid + 1   # חפש בחצי הימני
        else:
            high = mid - 1  # חפש בחצי השמאלי

    return -1  # לא נמצא
```

### מימוש רקורסיבי
```python
def binary_search_rec(lst, target, low, high):
    if low > high:
        return -1

    mid = (low + high) // 2

    if lst[mid] == target:
        return mid
    elif lst[mid] < target:
        return binary_search_rec(lst, target, mid + 1, high)
    else:
        return binary_search_rec(lst, target, low, mid - 1)
```

### מאפיינים
| מאפיין | ערך |
|--------|-----|
| דרישות מוקדמות | **רשימה ממוינת** |
| סיבוכיות זמן | O(log n) |
| סיבוכיות מקום (איטרטיבי) | O(1) |
| סיבוכיות מקום (רקורסיבי) | O(log n) |

---

## השוואה: לינארי מול בינארי

| קריטריון | לינארי | בינארי |
|----------|--------|--------|
| **דרישות** | אין | רשימה ממוינת |
| **סיבוכיות זמן** | O(n) | O(log n) |
| **פשטות מימוש** | פשוט מאוד | מורכב יותר |
| **מתאים ל...** | רשימות קטנות / לא ממוינות | רשימות גדולות ממוינות |

### המחשה מספרית
| גודל רשימה (n) | לינארי (עד n צעדים) | בינארי (עד log₂n צעדים) |
|----------------|---------------------|-------------------------|
| 10 | 10 | 4 |
| 100 | 100 | 7 |
| 1,000 | 1,000 | 10 |
| 1,000,000 | 1,000,000 | 20 |

---

## סיבוכיות זמן - הסבר

### למה O(log n)?
בכל איטרציה, אנחנו **מחצים** את טווח החיפוש:
- n → n/2 → n/4 → n/8 → ... → 1

**כמה פעמים אפשר לחלק n ב-2?**
```
n / 2^k = 1
n = 2^k
k = log₂(n)
```

### דוגמה
רשימה בגודל 16:
```
איטרציה 1: בודקים 16 איברים → נשארו 8
איטרציה 2: בודקים 8 איברים → נשארו 4
איטרציה 3: בודקים 4 איברים → נשארו 2
איטרציה 4: בודקים 2 איברים → נשארו 1
```
סה"כ: 4 = log₂(16) איטרציות

---

## טעויות נפוצות

### טעות 1: שימוש ברשימה לא ממוינת
```python
lst = [5, 2, 8, 1, 9]  # לא ממוינת!
binary_search(lst, 8)   # תוצאה שגויה!
```

### טעות 2: תנאי לולאה שגוי
```python
# שגוי
while low < high:  # צריך להיות <=

# נכון
while low <= high:
```

### טעות 3: עדכון גבולות שגוי
```python
# שגוי - לולאה אינסופית
low = mid      # צריך mid + 1
high = mid     # צריך mid - 1

# נכון
low = mid + 1
high = mid - 1
```

### טעות 4: חישוב mid עם overflow (בשפות אחרות)
```python
# בפייתון אין בעיה, אבל בשפות אחרות:
mid = (low + high) // 2      # עלול לגלוש
mid = low + (high - low) // 2  # בטוח יותר
```

---

## שאלות בחינתיות

### שאלה 1: כמה השוואות?
רשימה ממוינת בגודל 1000. מה מספר ההשוואות **המקסימלי** בחיפוש בינארי?

**תשובה:** ⌈log₂(1000)⌉ = 10 השוואות

---

### שאלה 2: מעקב
```python
lst = [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
# מצא את 23
```
| איטרציה | low | high | mid | lst[mid] | פעולה |
|---------|-----|------|-----|----------|-------|
| 1 | 0 | 9 | 4 | 16 | 16 < 23, low = 5 |
| 2 | 5 | 9 | 7 | 56 | 56 > 23, high = 6 |
| 3 | 5 | 6 | 5 | 23 | נמצא! החזר 5 |

---

### שאלה 3: מתי להשתמש בכל אחד?
- **לינארי:** רשימה קטנה, לא ממוינת, או חיפוש חד-פעמי
- **בינארי:** רשימה גדולה וממוינת, חיפושים מרובים

---

## סיכום נקודות חשובות

- [ ] חיפוש בינארי דורש **רשימה ממוינת**
- [ ] סיבוכיות: לינארי O(n), בינארי O(log n)
- [ ] תנאי הלולאה: `while low <= high`
- [ ] עדכון גבולות: `mid + 1` ו-`mid - 1` (לא `mid`!)
- [ ] לדעת לעשות מעקב ידני על חיפוש בינארי
