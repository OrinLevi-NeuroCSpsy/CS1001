# מילונים וקבוצות (Dictionaries & Sets) - סיכום לבחינה

---

## חלק א': מילונים (Dictionaries)

### הגדרה פורמלית

**מילון (Dictionary)** הוא מבנה נתונים המאחסן זוגות של **מפתח-ערך (key-value pairs)**, כאשר כל מפתח הוא ייחודי.

```python
d = {key1: value1, key2: value2, ...}
```

### מאפיינים

| מאפיין | ערך |
|--------|-----|
| סדר | כן (מ-Python 3.7+) - לפי סדר הכנסה |
| Mutable | כן - ניתן לשנות |
| מפתחות כפולים | **לא** - מפתח חייב להיות ייחודי |
| ערכים כפולים | כן - מותר |
| סוג מפתחות | **Immutable בלבד** (str, int, tuple) |
| סוג ערכים | כל טיפוס |

### הסבר אינטואיטיבי

מילון הוא כמו **ספר טלפונים**: לכל שם (מפתח) יש מספר טלפון (ערך). אי אפשר ששני אנשים יהיו עם אותו שם בדיוק, אבל יכול להיות לשניים אותו מספר.

```
מפתח (Key)     ערך (Value)
+-----------+  +-----------+
| "דני"     | → | "052-111" |
| "רוני"    | → | "054-222" |
| "יוסי"    | → | "052-111" |  ← אותו ערך, מפתח שונה
+-----------+  +-----------+
```

---

### יצירת מילונים

```python
# מילון ריק
empty = {}
empty = dict()

# מילון עם ערכים
ages = {"דני": 25, "רוני": 30, "יוסי": 28}

# מרשימת tuples
pairs = [("a", 1), ("b", 2)]
d = dict(pairs)  # {"a": 1, "b": 2}

# עם dict comprehension
squares = {x: x**2 for x in range(5)}  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}
```

---

### גישה לערכים

```python
d = {"a": 1, "b": 2, "c": 3}

# גישה ישירה (זורק KeyError אם אין)
d["a"]      # 1
d["x"]      # KeyError!

# גישה בטוחה עם get (מחזיר None או ברירת מחדל)
d.get("a")       # 1
d.get("x")       # None
d.get("x", 0)    # 0 (ברירת מחדל)
```

---

### הוספה ועדכון

```python
d = {"a": 1}

# הוספה/עדכון ישיר
d["b"] = 2      # הוספה: {"a": 1, "b": 2}
d["a"] = 10     # עדכון: {"a": 10, "b": 2}

# עדכון מרובה
d.update({"c": 3, "d": 4})
d.update(e=5, f=6)  # גם ככה אפשר
```

---

### מחיקה

```python
d = {"a": 1, "b": 2, "c": 3}

# del - מחיקה לפי מפתח
del d["a"]      # {"b": 2, "c": 3}
del d["x"]      # KeyError!

# pop - מחיקה והחזרת הערך
val = d.pop("b")      # val=2, d={"c": 3}
val = d.pop("x", 0)   # val=0 (ברירת מחדל, אין שגיאה)

# clear - ריקון המילון
d.clear()       # {}
```

---

### בדיקת קיום מפתח

```python
d = {"a": 1, "b": 2}

# בדיקה עם in (מומלץ)
"a" in d        # True
"x" in d        # False
"x" not in d    # True

# שימו לב: in בודק מפתחות, לא ערכים!
1 in d          # False (1 הוא ערך, לא מפתח)
```

---

### לולאות על מילונים

```python
d = {"a": 1, "b": 2, "c": 3}

# על מפתחות (ברירת מחדל)
for key in d:
    print(key)          # a, b, c

for key in d.keys():
    print(key)          # a, b, c

# על ערכים
for val in d.values():
    print(val)          # 1, 2, 3

# על זוגות (מפתח, ערך)
for key, val in d.items():
    print(f"{key}: {val}")
```

---

### מתודות של מילונים

| מתודה | פעולה | מחזירה |
|-------|-------|--------|
| `d[key]` | גישה לערך | ערך או KeyError |
| `d.get(key, default)` | גישה בטוחה | ערך או default |
| `d[key] = val` | הוספה/עדכון | - |
| `d.pop(key)` | מחיקה והחזרה | הערך |
| `d.keys()` | כל המפתחות | dict_keys |
| `d.values()` | כל הערכים | dict_values |
| `d.items()` | כל הזוגות | dict_items |
| `key in d` | בדיקת קיום | bool |
| `len(d)` | מספר זוגות | int |
| `d.update(other)` | מיזוג מילונים | None |
| `d.clear()` | ריקון | None |
| `d.copy()` | העתקה רדודה | dict |

---

### סיבוכיות פעולות על מילון

| פעולה | סיבוכיות ממוצעת | הערה |
|-------|-----------------|------|
| גישה `d[key]` | **O(1)** | Hash table |
| הוספה/עדכון | **O(1)** | |
| מחיקה | **O(1)** | |
| `key in d` | **O(1)** | יתרון מרכזי! |
| לולאה על כולם | O(n) | |

> **חשוב:** בניגוד לרשימה, חיפוש במילון הוא O(1) ולא O(n)!

---

## חלק ב': קבוצות (Sets)

### הגדרה פורמלית

**קבוצה (Set)** היא אוסף **לא סדור** של איברים **ייחודיים**.

```python
s = {element1, element2, element3, ...}
```

### מאפיינים

| מאפיין | ערך |
|--------|-----|
| סדר | **לא** - אין סדר מוגדר |
| Mutable | כן (`set`) / לא (`frozenset`) |
| כפילויות | **לא** - כל איבר מופיע פעם אחת |
| סוג איברים | **Immutable בלבד** |

### הסבר אינטואיטיבי

קבוצה היא כמו **שקית גולות**: לא משנה באיזה סדר הכנסת, ואם יש לך כבר גולה אדומה, עוד אחת לא תתווסף.

---

### יצירת קבוצות

```python
# קבוצה עם ערכים
s = {1, 2, 3}

# קבוצה ריקה (חייב להשתמש ב-set!)
empty = set()       # נכון
empty = {}          # שגוי! זה מילון ריק

# מרשימה (מסיר כפילויות)
s = set([1, 2, 2, 3, 3, 3])  # {1, 2, 3}

# ממחרוזת
s = set("hello")    # {'h', 'e', 'l', 'o'}

# set comprehension
evens = {x for x in range(10) if x % 2 == 0}  # {0, 2, 4, 6, 8}
```

---

### פעולות בסיסיות

```python
s = {1, 2, 3}

# הוספה
s.add(4)        # {1, 2, 3, 4}
s.add(2)        # {1, 2, 3, 4} - כבר קיים, אין שינוי

# מחיקה
s.remove(3)     # {1, 2, 4} - KeyError אם אין
s.discard(3)    # אין שגיאה אם לא קיים
s.pop()         # מסיר ומחזיר איבר אקראי

# בדיקת שייכות
2 in s          # True - O(1)!
5 in s          # False
```

---

### פעולות קבוצתיות (Set Operations)

```python
a = {1, 2, 3, 4}
b = {3, 4, 5, 6}

# איחוד (Union) - כל האיברים משתיהן
a | b           # {1, 2, 3, 4, 5, 6}
a.union(b)      # {1, 2, 3, 4, 5, 6}

# חיתוך (Intersection) - רק משותפים
a & b           # {3, 4}
a.intersection(b)

# הפרש (Difference) - ב-a אבל לא ב-b
a - b           # {1, 2}
a.difference(b)

# הפרש סימטרי - באחת אבל לא בשתיהן
a ^ b           # {1, 2, 5, 6}
a.symmetric_difference(b)
```

### תרשים Venn

```
    a = {1,2,3,4}        b = {3,4,5,6}

         a | b (איחוד)
    ┌─────────────────────┐
    │  1  2  ┌───┐  5  6  │
    │        │3 4│        │
    │        └───┘        │
    └─────────────────────┘
              a & b (חיתוך)

    a - b = {1, 2}    b - a = {5, 6}
```

---

### בדיקות על קבוצות

```python
a = {1, 2, 3}
b = {1, 2, 3, 4, 5}
c = {1, 2, 3}

# תת-קבוצה (Subset)
a <= b          # True - a מוכלת ב-b
a.issubset(b)   # True

# תת-קבוצה ממש
a < b           # True - מוכלת אבל לא שווה
a < c           # False - שוות

# על-קבוצה (Superset)
b >= a          # True
b.issuperset(a)

# קבוצות זרות (Disjoint) - אין חיתוך
{1, 2}.isdisjoint({3, 4})  # True
{1, 2}.isdisjoint({2, 3})  # False
```

---

### מתודות של קבוצות

| מתודה | פעולה | מחזירה |
|-------|-------|--------|
| `s.add(x)` | הוספה | None |
| `s.remove(x)` | מחיקה (KeyError אם אין) | None |
| `s.discard(x)` | מחיקה (בלי שגיאה) | None |
| `s.pop()` | הסרת איבר אקראי | האיבר |
| `x in s` | בדיקת שייכות | bool |
| `len(s)` | גודל | int |
| `s.union(t)` / `s \| t` | איחוד | set |
| `s.intersection(t)` / `s & t` | חיתוך | set |
| `s.difference(t)` / `s - t` | הפרש | set |
| `s.issubset(t)` / `s <= t` | תת-קבוצה? | bool |
| `s.clear()` | ריקון | None |

---

### סיבוכיות פעולות על קבוצה

| פעולה | סיבוכיות |
|-------|----------|
| `x in s` | **O(1)** |
| `add`, `remove` | **O(1)** |
| `union`, `intersection` | O(min(n,m)) עד O(n+m) |
| לולאה | O(n) |

---

## חלק ג': מתי להשתמש במה?

| מצב | מבנה מומלץ | סיבה |
|-----|-----------|------|
| שמירת ערכים לפי מפתח | **dict** | גישה מהירה O(1) |
| הסרת כפילויות | **set** | אוטומטית |
| בדיקת שייכות מהירה | **set** | O(1) במקום O(n) |
| ספירת הופעות | **dict** | key=איבר, value=כמות |
| שמירת סדר הכנסה | **list** או **dict** | set לא שומר סדר |
| פעולות קבוצתיות | **set** | union, intersection וכו' |

---

## חלק ד': טעויות נפוצות

### טעות 1: קבוצה ריקה עם סוגריים מסולסלים

```python
# שגוי!
empty_set = {}      # זה מילון ריק, לא קבוצה!
type({})            # <class 'dict'>

# נכון
empty_set = set()
type(set())         # <class 'set'>
```

### טעות 2: מפתח/איבר מסוג Mutable

```python
# שגוי! רשימה היא mutable
d = {[1, 2]: "value"}   # TypeError: unhashable type: 'list'
s = {[1, 2, 3]}         # TypeError

# נכון - tuple הוא immutable
d = {(1, 2): "value"}   # עובד
s = {(1, 2, 3)}         # עובד
```

### טעות 3: שכחה ש-set לא שומר סדר

```python
s = {3, 1, 4, 1, 5}
list(s)    # יכול להיות [1, 3, 4, 5] - לא בהכרח לפי סדר הכנסה!
```

### טעות 4: שינוי מילון/קבוצה תוך כדי לולאה

```python
# שגוי!
d = {"a": 1, "b": 2, "c": 3}
for key in d:
    if d[key] < 2:
        del d[key]      # RuntimeError!

# נכון - לולאה על העתק
for key in list(d.keys()):
    if d[key] < 2:
        del d[key]
```

### טעות 5: בלבול בין in על מילון

```python
d = {"a": 1, "b": 2}

"a" in d        # True - בודק מפתחות
1 in d          # False - לא בודק ערכים!
1 in d.values() # True - ככה בודקים ערכים
```

---

## חלק ה': דוגמאות שימושיות

### ספירת הופעות

```python
def count_chars(s):
    counts = {}
    for char in s:
        counts[char] = counts.get(char, 0) + 1
    return counts

count_chars("hello")  # {'h': 1, 'e': 1, 'l': 2, 'o': 1}
```

### הסרת כפילויות עם שמירת סדר

```python
def remove_duplicates(lst):
    seen = set()
    result = []
    for item in lst:
        if item not in seen:
            seen.add(item)
            result.append(item)
    return result

remove_duplicates([3, 1, 2, 1, 3])  # [3, 1, 2]
```

### מציאת איברים משותפים

```python
list1 = [1, 2, 3, 4, 5]
list2 = [4, 5, 6, 7, 8]

common = set(list1) & set(list2)  # {4, 5}
```

---

## חלק ו': שאלות בחינה טיפוסיות

### שאלה 1: מה יודפס?

```python
d = {"a": 1, "b": 2}
d["c"] = d.get("c", 0) + 1
print(d)
```

**תשובה:** `{"a": 1, "b": 2, "c": 1}`

---

### שאלה 2: מה יודפס?

```python
s = {1, 2, 3}
s.add(2)
s.add(4)
print(len(s))
```

**תשובה:** `4` (הוספת 2 לא משנה כי כבר קיים)

---

### שאלה 3: מה הסיבוכיות?

```python
def has_duplicates(lst):
    return len(lst) != len(set(lst))
```

**תשובה:** O(n) - יצירת set היא O(n), len היא O(1)

---

### שאלה 4: כתוב פונקציה שמחזירה מילון הפוך

```python
def invert_dict(d):
    """מחליף בין מפתחות לערכים"""
    return {v: k for k, v in d.items()}

# דוגמה:
invert_dict({"a": 1, "b": 2})  # {1: "a", 2: "b"}
```

---

### שאלה 5: מה השגיאה?

```python
d = {[1, 2]: "value"}
```

**תשובה:** `TypeError: unhashable type: 'list'` - מפתח חייב להיות immutable

---

## סיכום נקודות חשובות

### מילונים:
- [ ] זוגות key-value, מפתח ייחודי
- [ ] מפתח חייב להיות **immutable**
- [ ] גישה, הוספה, מחיקה, חיפוש: **O(1)**
- [ ] `get(key, default)` למניעת KeyError
- [ ] `in` בודק מפתחות, לא ערכים

### קבוצות:
- [ ] איברים ייחודיים, **ללא סדר**
- [ ] איברים חייבים להיות **immutable**
- [ ] `{}` זה מילון ריק! קבוצה ריקה: `set()`
- [ ] פעולות קבוצתיות: `|`, `&`, `-`, `^`
- [ ] חיפוש: **O(1)**
