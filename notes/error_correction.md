# גילוי ותיקון שגיאות (Error Detection & Correction) - סיכום לבחינה

---

## מוטיבציה

### הבעיה
כשמעבירים מידע (ברשת, בזיכרון, בדיסק) עלולות לקרות **שגיאות**:
- ביט מתהפך מ-0 ל-1 או להיפך
- רעש בקו תקשורת
- קרינה קוסמית (!)

### הפתרון: קודי שגיאה
מוסיפים **יתירות** (redundancy) שמאפשרת:
1. **גילוי שגיאה** (Error Detection) - לדעת שמשהו השתבש
2. **תיקון שגיאה** (Error Correction) - לתקן בלי לבקש שידור חוזר

---

## מושגי יסוד

### מרחק Hamming

**הגדרה:** מספר הביטים השונים בין שתי מילים באותו אורך.

```python
def hamming_distance(s1, s2):
    """מרחק המינג בין שתי מחרוזות ביטים"""
    if len(s1) != len(s2):
        raise ValueError("אורכים שונים")
    return sum(c1 != c2 for c1, c2 in zip(s1, s2))

hamming_distance("1010", "1001")  # 2 (ביט 2 ו-3 שונים)
hamming_distance("0000", "1111")  # 4
hamming_distance("1100", "1100")  # 0
```

### מרחק מינימלי של קוד

**הגדרה:** המרחק הקטן ביותר בין כל שתי מילות קוד חוקיות.

```
קוד: {000, 111}
מרחק מינימלי = 3

קוד: {00, 01, 10, 11}
מרחק מינימלי = 1
```

### יחס למרחק ויכולות הקוד

| מרחק מינימלי d | גילוי | תיקון |
|----------------|-------|-------|
| d | עד d-1 שגיאות | עד ⌊(d-1)/2⌋ שגיאות |

**דוגמאות:**
- d=2: גילוי 1 שגיאה, תיקון 0
- d=3: גילוי 2 שגיאות, תיקון 1
- d=4: גילוי 3 שגיאות, תיקון 1
- d=7: גילוי 6 שגיאות, תיקון 3

---

## ביט זוגיות (Parity Bit)

### הרעיון
מוסיפים ביט אחד כך שמספר ה-1 יהיה זוגי (או אי-זוגי).

### סוגי זוגיות

| סוג | כלל |
|-----|-----|
| **Even Parity** | מספר ה-1 זוגי |
| **Odd Parity** | מספר ה-1 אי-זוגי |

### מימוש

```python
def add_parity(data, odd=False):
    """מוסיף ביט זוגיות"""
    ones = data.count('1')
    if odd:
        parity = '0' if ones % 2 == 1 else '1'
    else:  # even parity
        parity = '0' if ones % 2 == 0 else '1'
    return data + parity

def check_parity(data_with_parity, odd=False):
    """בודק זוגיות"""
    ones = data_with_parity.count('1')
    if odd:
        return ones % 2 == 1
    else:
        return ones % 2 == 0

# דוגמאות
add_parity("1010")      # "10100" (2 אחדות, זוגי → 0)
add_parity("1011")      # "10111" (3 אחדות, אי-זוגי → 1)

check_parity("10100")   # True (תקין)
check_parity("10110")   # False (שגיאה!)
```

### דוגמה

```
נתון: 1011010

ספירת אחדות: 4 (זוגי)
Even parity: 10110100 (מוסיפים 0)

אם הגיע: 10110110 (ביט התהפך)
ספירת אחדות: 5 (אי-זוגי)
→ גילינו שגיאה!
```

### מגבלות

| יכולת | ביט זוגיות |
|-------|------------|
| גילוי 1 שגיאה | ✓ |
| גילוי 2 שגיאות | ✗ (מתקזזות!) |
| תיקון | ✗ |

**למה לא מתקן?** יודעים שיש שגיאה, אבל לא יודעים **איפה**.

---

## קוד Hamming

### הרעיון
מרחיב את רעיון הזוגיות: **מספר ביטי בדיקה** שכל אחד בודק קבוצה אחרת של ביטים.

### Hamming(7,4)
- 4 ביטי מידע (data bits)
- 3 ביטי בדיקה (parity bits)
- סה"כ 7 ביטים
- מתקן שגיאה אחת

### מיקומי הביטים

```
מיקום:  1   2   3   4   5   6   7
סוג:    p1  p2  d1  p3  d2  d3  d4
```

- **p1, p2, p3** = ביטי בדיקה (במיקומים שהם חזקות של 2)
- **d1, d2, d3, d4** = ביטי מידע

### מי בודק מי?

כל ביט בדיקה pᵢ בודק את המיקומים שבייצוג הבינארי שלהם הביט ה-i דלוק.

```
p1 (מיקום 1 = 001₂): בודק מיקומים עם ביט 1 דלוק
   → 1, 3, 5, 7 (001, 011, 101, 111)

p2 (מיקום 2 = 010₂): בודק מיקומים עם ביט 2 דלוק
   → 2, 3, 6, 7 (010, 011, 110, 111)

p3 (מיקום 4 = 100₂): בודק מיקומים עם ביט 3 דלוק
   → 4, 5, 6, 7 (100, 101, 110, 111)
```

**טבלה:**
```
מיקום    1   2   3   4   5   6   7
בינארי  001 010 011 100 101 110 111
         p1  p2  d1  p3  d2  d3  d4

p1 בודק: 1       3       5       7
p2 בודק:     2   3           6   7
p3 בודק:             4   5   6   7
```

### קידוד

```python
def hamming_encode(data):
    """קידוד Hamming(7,4)"""
    if len(data) != 4:
        raise ValueError("צריך 4 ביטים")

    d = [int(b) for b in data]

    # מיקומי הביטים: _ _ d1 _ d2 d3 d4
    # אינדקסים:      1 2 3  4 5  6  7

    # p1 בודק 1,3,5,7 → d1,d2,d4
    p1 = d[0] ^ d[1] ^ d[3]

    # p2 בודק 2,3,6,7 → d1,d3,d4
    p2 = d[0] ^ d[2] ^ d[3]

    # p3 בודק 4,5,6,7 → d2,d3,d4
    p3 = d[1] ^ d[2] ^ d[3]

    return f"{p1}{p2}{d[0]}{p3}{d[1]}{d[2]}{d[3]}"

hamming_encode("1011")  # "0110011"
```

### פענוח ותיקון

```python
def hamming_decode(code):
    """פענוח ותיקון Hamming(7,4)"""
    if len(code) != 7:
        raise ValueError("צריך 7 ביטים")

    c = [int(b) for b in code]

    # חישוב סינדרום (syndrome)
    s1 = c[0] ^ c[2] ^ c[4] ^ c[6]  # מיקומים 1,3,5,7
    s2 = c[1] ^ c[2] ^ c[5] ^ c[6]  # מיקומים 2,3,6,7
    s3 = c[3] ^ c[4] ^ c[5] ^ c[6]  # מיקומים 4,5,6,7

    # הסינדרום מציין את מיקום השגיאה
    error_pos = s1 + 2*s2 + 4*s3

    if error_pos != 0:
        # תיקון השגיאה
        c[error_pos - 1] ^= 1
        print(f"תוקנה שגיאה במיקום {error_pos}")

    # החזרת ביטי המידע
    return f"{c[2]}{c[4]}{c[5]}{c[6]}"

# דוגמה
code = "0110011"
hamming_decode(code)  # "1011"

# עם שגיאה
corrupted = "0110001"  # ביט 6 התהפך
hamming_decode(corrupted)  # מתקן ומחזיר "1011"
```

### דוגמה מלאה

```
קידוד 1011:

ביטי מידע: d1=1, d2=0, d3=1, d4=1

חישוב ביטי בדיקה:
p1 = d1 ⊕ d2 ⊕ d4 = 1 ⊕ 0 ⊕ 1 = 0
p2 = d1 ⊕ d3 ⊕ d4 = 1 ⊕ 1 ⊕ 1 = 1
p3 = d2 ⊕ d3 ⊕ d4 = 0 ⊕ 1 ⊕ 1 = 0

מילת קוד: 0 1 1 0 0 1 1
          p1 p2 d1 p3 d2 d3 d4

תיקון שגיאה:
נניח שהתקבל: 0 1 1 0 1 1 1 (ביט 5 התהפך)
                        ^
סינדרום:
s1 = 0 ⊕ 1 ⊕ 1 ⊕ 1 = 1
s2 = 1 ⊕ 1 ⊕ 1 ⊕ 1 = 0
s3 = 0 ⊕ 1 ⊕ 1 ⊕ 1 = 1

error_pos = 1 + 0 + 4 = 5

מתקנים ביט 5: 0 1 1 0 0 1 1 ✓
```

---

## קוד Hamming מורחב - SECDED

### מהו?
**Single Error Correction, Double Error Detection**

מוסיפים ביט זוגיות כללי שבודק את כל הביטים.

### Hamming(8,4)
- 4 ביטי מידע
- 3 ביטי Hamming
- 1 ביט זוגיות כללי
- סה"כ 8 ביטים

### יכולות

| מצב | סינדרום | זוגיות כללית | פעולה |
|-----|---------|--------------|-------|
| תקין | 0 | תקינה | בסדר |
| שגיאה אחת | ≠0 | לא תקינה | תקן |
| שתי שגיאות | ≠0 | תקינה | התראה (לא מתקנים!) |

---

## ביט זוגיות דו-ממדי

### הרעיון
מסדרים את הביטים במטריצה ומחשבים זוגיות לכל שורה ועמודה.

```
מידע:
1 0 1 | 0  ← זוגיות שורה
0 1 1 | 0
1 1 0 | 0
------+--
0 0 0 | 0  ← זוגיות עמודה
```

### יכולות
- **גילוי**: עד 3 שגיאות
- **תיקון**: 1 שגיאה (הצטלבות שורה ועמודה שגויות)

### מימוש

```python
def create_2d_parity(data, rows, cols):
    """יוצר מטריצה עם זוגיות דו-ממדית"""
    # data הוא מחרוזת ביטים
    matrix = []
    idx = 0

    for r in range(rows):
        row = []
        for c in range(cols):
            row.append(int(data[idx]))
            idx += 1
        # זוגיות שורה
        row.append(sum(row) % 2)
        matrix.append(row)

    # שורת זוגיות עמודות
    parity_row = []
    for c in range(cols + 1):
        col_sum = sum(matrix[r][c] for r in range(rows))
        parity_row.append(col_sum % 2)
    matrix.append(parity_row)

    return matrix

def check_2d_parity(matrix):
    """בודק ומתקן שגיאה"""
    rows = len(matrix)
    cols = len(matrix[0])

    bad_row = -1
    bad_col = -1

    # בדיקת שורות
    for r in range(rows):
        if sum(matrix[r]) % 2 != 0:
            bad_row = r

    # בדיקת עמודות
    for c in range(cols):
        if sum(matrix[r][c] for r in range(rows)) % 2 != 0:
            bad_col = c

    if bad_row >= 0 and bad_col >= 0:
        print(f"שגיאה במיקום ({bad_row}, {bad_col})")
        matrix[bad_row][bad_col] ^= 1
        return True

    return False
```

---

## Checksum

### הרעיון
סכימת ערכים מספריים ושמירת התוצאה לבדיקה.

### מימוש פשוט

```python
def simple_checksum(data, bits=8):
    """checksum פשוט"""
    total = sum(ord(c) for c in data)
    return total % (2 ** bits)

def verify_checksum(data, checksum, bits=8):
    return simple_checksum(data, bits) == checksum

# דוגמה
data = "Hello"
cs = simple_checksum(data)  # 500 % 256 = 244
verify_checksum(data, 244)  # True
```

### Internet Checksum

```python
def internet_checksum(data):
    """Checksum כמו בפרוטוקולי אינטרנט"""
    if len(data) % 2:
        data += b'\x00'

    total = 0
    for i in range(0, len(data), 2):
        word = (data[i] << 8) + data[i+1]
        total += word

    # fold carry
    while total >> 16:
        total = (total & 0xFFFF) + (total >> 16)

    return ~total & 0xFFFF
```

---

## CRC (Cyclic Redundancy Check)

### הרעיון
חילוק פולינומים בחשבון מודולו 2 (XOR).

### איך עובד?
1. מייצגים את המידע כפולינום
2. מחלקים בפולינום generator קבוע
3. השארית היא ה-CRC

### דוגמה פשוטה

```python
def crc_simple(data, generator):
    """חישוב CRC פשוט"""
    # data ו-generator הם מחרוזות ביטים
    gen_len = len(generator)
    data = data + '0' * (gen_len - 1)  # padding
    data = list(data)

    for i in range(len(data) - gen_len + 1):
        if data[i] == '1':
            for j in range(gen_len):
                data[i + j] = str(int(data[i + j]) ^ int(generator[j]))

    return ''.join(data[-(gen_len - 1):])

# דוגמה
data = "1101"
generator = "1011"
crc = crc_simple(data, generator)  # "100"
# שידור: data + crc = "1101100"
```

---

## טעויות נפוצות

### טעות 1: בלבול בין גילוי לתיקון

```
ביט זוגיות: מגלה שגיאה אחת, לא מתקן!
Hamming(7,4): מגלה 2, מתקן 1
```

### טעות 2: מרחק Hamming לעומת קוד Hamming

```
מרחק Hamming = מספר ביטים שונים בין שתי מילים
קוד Hamming = שיטת קידוד לתיקון שגיאות
```

### טעות 3: חישוב סינדרום שגוי

```
# האינדקסים מתחילים מ-1, לא מ-0!
מיקום 1 = ביט ראשון (אינדקס 0 במערך)
```

### טעות 4: שכחה ש-XOR הוא גם חיסור במודולו 2

```
0 ⊕ 0 = 0
0 ⊕ 1 = 1
1 ⊕ 0 = 1
1 ⊕ 1 = 0

a ⊕ a = 0 (כל מספר XOR עצמו = 0)
```

---

## שאלות בחינה טיפוסיות

### שאלה 1: מרחק Hamming

מהו מרחק Hamming בין 10110 ל-11011?

**פתרון:**
```
10110
11011
-----
01101  ← 3 ביטים שונים

תשובה: 3
```

---

### שאלה 2: קידוד Hamming

קודד את המידע 1010 ב-Hamming(7,4).

**פתרון:**
```
d1=1, d2=0, d3=1, d4=0

p1 = d1 ⊕ d2 ⊕ d4 = 1 ⊕ 0 ⊕ 0 = 1
p2 = d1 ⊕ d3 ⊕ d4 = 1 ⊕ 1 ⊕ 0 = 0
p3 = d2 ⊕ d3 ⊕ d4 = 0 ⊕ 1 ⊕ 0 = 1

מילת קוד: 1 0 1 1 0 1 0
          p1 p2 d1 p3 d2 d3 d4

תשובה: 1011010
```

---

### שאלה 3: תיקון שגיאה

התקבלה מילת Hamming: 1011110. תקן אם יש שגיאה.

**פתרון:**
```
ביטים: 1 0 1 1 1 1 0
מיקום: 1 2 3 4 5 6 7

סינדרום:
s1 = 1 ⊕ 1 ⊕ 1 ⊕ 0 = 1 (מיקומים 1,3,5,7)
s2 = 0 ⊕ 1 ⊕ 1 ⊕ 0 = 0 (מיקומים 2,3,6,7)
s3 = 1 ⊕ 1 ⊕ 1 ⊕ 0 = 1 (מיקומים 4,5,6,7)

error_pos = 1 + 0 + 4 = 5

ביט 5 שגוי: 1→0 או 0→1
מתוקן: 1011010

תשובה: 1011010, המידע הוא 1010
```

---

### שאלה 4: יכולות קוד

לקוד יש מרחק מינימלי 5. כמה שגיאות הוא יכול לגלות ולתקן?

**פתרון:**
```
גילוי: d-1 = 5-1 = 4 שגיאות
תיקון: ⌊(d-1)/2⌋ = ⌊4/2⌋ = 2 שגיאות
```

---

## סיכום נקודות חשובות

- [ ] **מרחק Hamming** = מספר ביטים שונים בין שתי מילים
- [ ] **ביט זוגיות** = מגלה שגיאה אחת, לא מתקן
- [ ] **Hamming(7,4)** = 4 מידע + 3 בדיקה, מתקן 1 שגיאה
- [ ] **ביטי בדיקה במיקומים** 1, 2, 4, 8, ... (חזקות של 2)
- [ ] **סינדרום** = מציין את מיקום השגיאה בבינארי
- [ ] מרחק d: גילוי d-1, תיקון ⌊(d-1)/2⌋
- [ ] **XOR** = חיבור/חיסור במודולו 2
- [ ] **SECDED** = Hamming + ביט זוגיות כללי
