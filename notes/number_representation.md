# ייצוג מספרים - בסיסי ספירה

---

## מהו בסיס מספרים?

### הגדרה פורמלית
**בסיס (Base/Radix)** הוא מספר הסמלים השונים בהם משתמשים לייצוג מספרים.

מספר בבסיס b עם n ספרות:
```
(dₙ₋₁ dₙ₋₂ ... d₁ d₀)ᵦ = dₙ₋₁·bⁿ⁻¹ + dₙ₋₂·bⁿ⁻² + ... + d₁·b¹ + d₀·b⁰
```

### הסבר אינטואיטיבי
כל ספרה במספר מייצגת כמות של "חבילות" בגודל מסוים.
בבסיס 10: יחידות, עשרות, מאות...
בבסיס 2: יחידות, זוגות, רביעיות, שמיניות...

---

## בסיס 10 (עשרוני - Decimal)

### מאפיינים
- **ספרות:** 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
- **שימוש:** חיי היום-יום

### דוגמה
```
357₁₀ = 3·10² + 5·10¹ + 7·10⁰
      = 3·100 + 5·10 + 7·1
      = 300 + 50 + 7
      = 357
```

---

## בסיס 2 (בינארי - Binary)

### מאפיינים
- **ספרות:** 0, 1 (נקראות bits)
- **שימוש:** מחשבים, אלקטרוניקה

### מונחים חשובים
| מונח | משמעות |
|------|--------|
| **bit** | ספרה בינארית אחת (0 או 1) |
| **byte** | 8 bits |
| **nibble** | 4 bits |

### טבלת חזקות של 2 (לשנן!)
| 2⁰ | 2¹ | 2² | 2³ | 2⁴ | 2⁵ | 2⁶ | 2⁷ | 2⁸ | 2⁹ | 2¹⁰ |
|----|----|----|----|----|----|----|----|----|----|----|
| 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024 |

### כמה ביטים צריך לייצג מספר n?

**נוסחה:**
```
מספר ביטים = ⌊log₂(n)⌋ + 1
```

**או באופן שקול:**
```
מספר ביטים = ⌈log₂(n + 1)⌉
```

**הסבר אינטואיטיבי:**
- עם k ביטים אפשר לייצג מספרים מ-0 עד 2ᵏ-1
- אם n ≤ 2ᵏ-1, אז k ביטים מספיקים
- לכן צריך למצוא את ה-k הקטן ביותר כך ש-2ᵏ > n

**דוגמאות:**

| n | log₂(n) | ביטים | הסבר |
|---|---------|-------|------|
| 1 | 0 | 1 | 2¹ = 2 > 1 ✓ |
| 7 | 2.81 | 3 | 2³ = 8 > 7 ✓ |
| 8 | 3 | 4 | 2³ = 8 לא מספיק (צריך 0-8), 2⁴ = 16 > 8 ✓ |
| 100 | 6.64 | 7 | 2⁷ = 128 > 100 ✓ |
| 255 | 7.99 | 8 | 2⁸ = 256 > 255 ✓ |
| 256 | 8 | 9 | 2⁸ = 256 לא מספיק, 2⁹ = 512 > 256 ✓ |
| 1000 | 9.97 | 10 | 2¹⁰ = 1024 > 1000 ✓ |

**בפייתון:**
```python
import math

def bits_needed(n):
    if n == 0:
        return 1
    return math.floor(math.log2(n)) + 1

# או פשוט:
def bits_needed(n):
    return n.bit_length()

# דוגמאות
(7).bit_length()    # 3
(8).bit_length()    # 4
(255).bit_length()  # 8
(256).bit_length()  # 9
```

**טיפ לבחינה:** אם n = 2ᵏ בדיוק, צריך k+1 ביטים (כי צריך לייצג גם את 0).

### דוגמה: בינארי לעשרוני
```
1011₂ = 1·2³ + 0·2² + 1·2¹ + 1·2⁰
      = 1·8 + 0·4 + 1·2 + 1·1
      = 8 + 0 + 2 + 1
      = 11₁₀
```

---

## בסיס 16 (הקסדצימלי - Hexadecimal)

### מאפיינים
- **ספרות:** 0-9, A, B, C, D, E, F
- **שימוש:** כתובות זיכרון, צבעים, קיצור של בינארי

### טבלת המרה הקסדצימלי-עשרוני
| Hex | Dec | Binary |
|-----|-----|--------|
| 0 | 0 | 0000 |
| 1 | 1 | 0001 |
| 2 | 2 | 0010 |
| 3 | 3 | 0011 |
| 4 | 4 | 0100 |
| 5 | 5 | 0101 |
| 6 | 6 | 0110 |
| 7 | 7 | 0111 |
| 8 | 8 | 1000 |
| 9 | 9 | 1001 |
| A | 10 | 1010 |
| B | 11 | 1011 |
| C | 12 | 1100 |
| D | 13 | 1101 |
| E | 14 | 1110 |
| F | 15 | 1111 |

### דוגמה: הקסדצימלי לעשרוני
```
2A₁₆ = 2·16¹ + 10·16⁰
     = 2·16 + 10·1
     = 32 + 10
     = 42₁₀
```

### קשר בין הקסדצימלי לבינארי
כל ספרה הקסדצימלית = 4 ספרות בינאריות (nibble)
```
2A₁₆ = 0010 1010₂
  2  =  0010
  A  =  1010
```

---

## למה מחשבים עובדים בבינארי?

### סיבות פיזיות
1. **מתח חשמלי:** קל להבחין בין שני מצבים (יש מתח / אין מתח)
2. **אמינות:** פחות שגיאות מאשר להבחין בין 10 רמות מתח
3. **פשטות חומרה:** טרנזיסטור = מתג on/off

### סיבות לוגיות
1. **אלגברה בוליאנית:** מתאים ללוגיקה (True/False)
2. **שערים לוגיים:** AND, OR, NOT עובדים עם 0 ו-1

---

## המרות בין בסיסים

### עשרוני → בינארי (חילוק ב-2)

**שיטה:** חלק ב-2 שוב ושוב, רשום את השאריות מלמטה למעלה.

**דוגמה: המר 25 לבינארי**
```
25 ÷ 2 = 12  שארית 1  ↑
12 ÷ 2 = 6   שארית 0  |
6  ÷ 2 = 3   שארית 0  |
3  ÷ 2 = 1   שארית 1  |
1  ÷ 2 = 0   שארית 1  |
                      קרא מלמטה למעלה

25₁₀ = 11001₂
```

**בדיקה:**
```
11001₂ = 16 + 8 + 0 + 0 + 1 = 25 ✓
```

---

### עשרוני → הקסדצימלי (חילוק ב-16)

**דוגמה: המר 500 להקסדצימלי**
```
500 ÷ 16 = 31  שארית 4   ↑
31  ÷ 16 = 1   שארית 15 (F)  |
1   ÷ 16 = 0   שארית 1   |

500₁₀ = 1F4₁₆
```

**בדיקה:**
```
1F4₁₆ = 1·256 + 15·16 + 4·1 = 256 + 240 + 4 = 500 ✓
```

---

### בינארי → עשרוני (סכום חזקות)

**דוגמה: המר 110101₂ לעשרוני**
```
מיקום:  5  4  3  2  1  0
ספרה:   1  1  0  1  0  1
חזקה:  32 16  8  4  2  1

110101₂ = 32 + 16 + 0 + 4 + 0 + 1 = 53₁₀
```

---

### בינארי ↔ הקסדצימלי (קיבוץ/פירוק)

**בינארי → הקסדצימלי:** קבץ לרביעיות מימין לשמאל
```
11010110₂ = 1101 0110₂
            = D    6
            = D6₁₆
```

**הקסדצימלי → בינארי:** החלף כל ספרה ב-4 bits
```
3F₁₆ = 0011 1111₂
```

---

## סימונים בפייתון

| בסיס | קידומת | דוגמה |
|------|--------|-------|
| בינארי | `0b` | `0b1010` |
| אוקטלי | `0o` | `0o17` |
| הקסדצימלי | `0x` | `0xFF` |

---

## ייצוג מספרים שליליים - Two's Complement

### הבעיה
איך מייצגים מספרים שליליים בבינארי?

### שיטת המשלים ל-2 (Two's Complement)

**הרעיון:** הביט השמאלי ביותר (MSB) מציין את הסימן:
- `0` = חיובי
- `1` = שלילי

### המרה למשלים ל-2

**שלב 1:** הפוך את כל הביטים (0↔1)
**שלב 2:** הוסף 1

**דוגמה: ייצג -5 ב-8 ביטים**
```
5 בבינארי:     00000101
הפיכה:         11111010
הוסף 1:        11111011

-5 = 11111011₂
```

### המרה הפוכה (משלילי לחיובי)

אותו תהליך בדיוק!

```
-5 = 11111011
הפיכה: 00000100
הוסף 1: 00000101 = 5 ✓
```

### טווחי ערכים עם סימן

| ביטים | טווח |
|-------|------|
| 8 bits | -128 עד 127 |
| 16 bits | -32,768 עד 32,767 |
| 32 bits | -2³¹ עד 2³¹-1 |

**נוסחה כללית:** n bits עם סימן → טווח **-2ⁿ⁻¹** עד **2ⁿ⁻¹-1**

### למה משלים ל-2?

**יתרון:** חיבור עובד אוטומטית!

```
  5 + (-3) = 2

  00000101   (5)
+ 11111101   (-3)
----------
 100000010   (התעלם מהנשא) = 00000010 = 2 ✓
```

### דוגמאות חשובות ב-8 ביטים

| עשרוני | בינארי (Two's Complement) |
|--------|---------------------------|
| 0 | 00000000 |
| 1 | 00000001 |
| 127 | 01111111 |
| -1 | 11111111 |
| -128 | 10000000 |

### טעות נפוצה: Overflow

```
127 + 1 = ?
01111111 + 00000001 = 10000000 = -128 (!)

זה נקרא overflow - יצאנו מהטווח!
```

---

## ייצוג מספרים עשרוניים - Floating Point

### הבעיה
איך מייצגים מספרים כמו 3.14 או 0.001 בבינארי?

### רעיון: סימון מדעי

כמו `6.02 × 10²³`, אבל בבינארי:
```
מספר = מנטיסה × 2^מעריך
```

### מבנה IEEE 754 (32 bit - float)

```
| סימן | מעריך  | מנטיסה       |
| 1 bit| 8 bits | 23 bits      |
```

- **סימן (Sign):** 0 = חיובי, 1 = שלילי
- **מעריך (Exponent):** קובע את "סדר הגודל"
- **מנטיסה (Mantissa/Fraction):** הספרות המשמעותיות

### דוגמה פשוטה

המספר 5.75 בבינארי:
```
5.75 = 5 + 0.75 = 101.11₂

בסימון מדעי: 1.0111 × 2²

סימן: 0 (חיובי)
מעריך: 2 + 127 = 129 = 10000001₂
מנטיסה: 01110000000000000000000

5.75 = 0 10000001 01110000000000000000000
```

### בעיות דיוק (Precision Problems)

**בעיה:** לא כל מספר עשרוני ניתן לייצוג מדויק!

```python
# בפייתון:
0.1 + 0.2
# 0.30000000000000004  (!)

0.1 + 0.2 == 0.3
# False (!)
```

**למה?** 0.1 בבסיס 2 הוא שבר אינסופי (כמו 1/3 בבסיס 10).

### פתרונות בפייתון

```python
# השוואה עם סובלנות
abs(a - b) < 0.0001

# מודול math
import math
math.isclose(0.1 + 0.2, 0.3)  # True

# מודול decimal (דיוק מלא)
from decimal import Decimal
Decimal('0.1') + Decimal('0.2') == Decimal('0.3')  # True
```

### ערכים מיוחדים

| ערך | משמעות |
|-----|--------|
| `inf` | אינסוף (1.0 / 0.0) |
| `-inf` | מינוס אינסוף |
| `nan` | Not a Number (0.0 / 0.0) |

```python
float('inf')   # אינסוף
float('-inf')  # מינוס אינסוף
float('nan')   # לא מספר
```

---

## שאלות בחינה טיפוסיות

### שאלה 1: המר לבינארי
**המר את 45₁₀ לבינארי**

```
45 ÷ 2 = 22  שארית 1
22 ÷ 2 = 11  שארית 0
11 ÷ 2 = 5   שארית 1
5  ÷ 2 = 2   שארית 1
2  ÷ 2 = 1   שארית 0
1  ÷ 2 = 0   שארית 1

תשובה: 45₁₀ = 101101₂
```

---

### שאלה 2: המר לעשרוני
**המר את 10110011₂ לעשרוני**

```
10110011₂ = 128 + 0 + 32 + 16 + 0 + 0 + 2 + 1
          = 179₁₀
```

---

### שאלה 3: המר הקסדצימלי לבינארי
**המר את 4B₁₆ לבינארי**

```
4₁₆ = 0100₂
B₁₆ = 1011₂

4B₁₆ = 01001011₂
```

---

### שאלה 4: מהו הטווח?
**מה הטווח של מספרים שניתן לייצג ב-8 bits (ללא סימן)?**

```
מינימום: 00000000₂ = 0
מקסימום: 11111111₂ = 255

טווח: 0 עד 2⁸-1 = 0 עד 255
כמות ערכים: 2⁸ = 256
```

**כלל כללי:** n bits ללא סימן → טווח 0 עד 2ⁿ-1

---

### שאלה 5: חיבור בינארי
**חשב: 1011₂ + 0110₂**

```
  1011
+ 0110
------
 10001
```

**הסבר:** נשא (carry) כמו בחיבור רגיל, אבל 1+1=10₂

---

### שאלה 6: Two's Complement
**ייצג את -20 ב-8 ביטים**

```
20 בבינארי: 00010100
הפיכה:      11101011
הוסף 1:     11101100

תשובה: -20 = 11101100₂
```

---

### שאלה 7: מה הערך?
**מהו הערך של 11110001₂ ב-Two's Complement (8 bits)?**

```
הביט השמאלי הוא 1 → מספר שלילי
הפיכה: 00001110
הוסף 1: 00001111 = 15

תשובה: -15
```

---

### שאלה 8: בעיות דיוק
**למה `0.1 + 0.2 != 0.3` בפייתון?**

**תשובה:** כי 0.1 ו-0.2 לא ניתנים לייצוג מדויק בבינארי (floating point). הם מיוצגים בקירוב, ולכן הסכום שלהם גם בקירוב.

---

## טעויות נפוצות

1. **שכחת סדר הספרות:** בחילוק - קוראים מלמטה למעלה
2. **בלבול A-F:** לזכור A=10, B=11, ..., F=15
3. **קיבוץ שגוי:** בבינארי להקסדצימלי - לקבץ מ**ימין** לשמאל
4. **חזקות לא נכונות:** הספרה הימנית היא 2⁰, לא 2¹

---

## סיכום נקודות חשובות

- [ ] לשנן טבלת חזקות של 2 עד 2¹⁰
- [ ] לשנן טבלת Hex (A=10 עד F=15)
- [ ] המרה לבינארי: חילוק ב-2, שאריות מלמטה למעלה
- [ ] בינארי להקסדצימלי: קיבוץ לרביעיות
- [ ] n bits ללא סימן: טווח 0 עד 2ⁿ-1
- [ ] **Two's Complement:** הפוך ביטים + הוסף 1
- [ ] n bits עם סימן: טווח -2ⁿ⁻¹ עד 2ⁿ⁻¹-1
- [ ] **Floating Point:** יש בעיות דיוק! השתמש ב-`math.isclose()`
- [ ] 0.1 + 0.2 ≠ 0.3 בגלל ייצוג בינארי לא מדויק

---

## קישורים נוספים

- **קוד:** [binary_and_hex.py](../code/binary_and_hex.py)
- **שאלות בחינה:** [cryptography_and_primes.md](../exam_questions/cryptography_and_primes.md)
